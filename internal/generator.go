package internal

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

// This file contains internal helper functions and code generation logic
// that isn't part of the public API.

// InterfaceInfo represents information about a Go interface for mock generation.
type InterfaceInfo struct {
	Name    string
	Package string
	Methods []MethodInfo
}

// MethodInfo represents information about a method in an interface.
type MethodInfo struct {
	Name       string
	Params     []ParamInfo
	Returns    []ParamInfo
	IsVariadic bool
}

// ParamInfo represents information about a method parameter or return value.
type ParamInfo struct {
	Name string
	Type string
}

// Template constants for code generation
const (
	mockTemplate = `// Code generated by GopherKit.Test; DO NOT EDIT.

package {{.Package}}

import (
	"testing"
	"github.com/g-restante/GopeherKit.Test/mock"
)

// {{.Name}}Mock is a mock implementation of {{.Name}}.
type {{.Name}}Mock struct {
	mock *mock.Mock
}

// New{{.Name}}Mock creates a new mock for {{.Name}}.
func New{{.Name}}Mock(t *testing.T) *{{.Name}}Mock {
	return &{{.Name}}Mock{
		mock: mock.NewMock(t),
	}
}

{{range .Methods}}
// {{.Name}} is a mock implementation of the {{.Name}} method.
func (m *{{$.Name}}Mock) {{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{.Name}} {{.Type}}{{end}}) ({{range $i, $r := .Returns}}{{if $i}}, {{end}}{{.Type}}{{end}}) {
	args := []any{ {{range .Params}}{{.Name}}, {{end}} }
	results := m.mock.Called("{{.Name}}", args...)
	{{if .Returns}}
	return {{range $i, $r := .Returns}}{{if $i}}, {{end}}results[{{$i}}].({{.Type}}){{end}}
	{{end}}
}

// On{{.Name}} sets up an expectation for the {{.Name}} method.
func (m *{{$.Name}}Mock) On{{.Name}}({{range $i, $p := .Params}}{{if $i}}, {{end}}{{.Name}} {{.Type}}{{end}}) *mock.Call {
	args := []any{ {{range .Params}}{{.Name}}, {{end}} }
	return m.mock.On("{{.Name}}", args...)
}
{{end}}

// AssertExpectations verifies that all expected method calls were made.
func (m *{{.Name}}Mock) AssertExpectations() {
	m.mock.AssertExpectations()
}
`

	testTemplate = `// Code generated by GopherKit.Test; DO NOT EDIT.

package {{.Package}}_test

import (
	"testing"
	"github.com/g-restante/GopeherKit.Test/assert"
)

// Test{{.Name}} is a basic test template.
func Test{{.Name}}(t *testing.T) {
	// TODO: Add your test implementation here
	
	// Example assertions:
	// assert.Equal(t, expected, actual, "description")
	// assert.True(t, condition, "description")
	// assert.NotNil(t, value, "description")
}
`

	assertionTemplate = `// Custom assertion for {{.Name}}
func {{.Name}}(t *testing.T, {{.Params}}, msg ...string) {
	t.Helper()
	
	if !({{.Condition}}) {
		var message string
		if len(msg) > 0 && msg[0] != "" {
			message = msg[0]
		} else {
			message = "{{.DefaultMessage}}"
		}
		
		t.Errorf(message)
	}
}
`
)

// Generator holds the configuration and state for code generation.
type Generator struct {
	// PackageName is the target package for generated code
	PackageName string
	// OutputDir is the directory where generated files will be written
	OutputDir string
	// Templates holds the code templates for generation
	Templates map[string]string
}

// NewGenerator creates a new code generator instance.
func NewGenerator(packageName, outputDir string) *Generator {
	return &Generator{
		PackageName: packageName,
		OutputDir:   outputDir,
		Templates:   make(map[string]string),
	}
}

// GenerateMocks generates mock implementations for the given interfaces.
func (g *Generator) GenerateMocks(interfaces []string) error {
	for _, interfacePath := range interfaces {
		interfaceInfo, err := g.parseInterface(interfacePath)
		if err != nil {
			return fmt.Errorf("failed to parse interface %s: %w", interfacePath, err)
		}

		mockCode, err := g.generateMockCode(interfaceInfo)
		if err != nil {
			return fmt.Errorf("failed to generate mock for %s: %w", interfaceInfo.Name, err)
		}

		outputPath := filepath.Join(g.OutputDir, strings.ToLower(interfaceInfo.Name)+"_mock.go")
		if err := g.writeFile(outputPath, mockCode); err != nil {
			return fmt.Errorf("failed to write mock file %s: %w", outputPath, err)
		}
	}
	return nil
}

// GenerateTestBoilerplate generates test file templates.
func (g *Generator) GenerateTestBoilerplate(packagePath string) error {
	packageName := filepath.Base(packagePath)
	
	testData := struct {
		Package string
		Name    string
	}{
		Package: packageName,
		Name:    strings.Title(packageName),
	}

	tmpl, err := template.New("test").Parse(testTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse test template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, testData); err != nil {
		return fmt.Errorf("failed to execute test template: %w", err)
	}

	outputPath := filepath.Join(g.OutputDir, packageName+"_test.go")
	return g.writeFile(outputPath, buf.String())
}

// AssertionSpec represents a custom assertion specification.
type AssertionSpec struct {
	Name           string
	Params         string
	Condition      string
	DefaultMessage string
}

// GenerateAssertions generates custom assertion functions.
func (g *Generator) GenerateAssertions(assertionSpecs []string) error {
	var allAssertions strings.Builder
	
	allAssertions.WriteString("// Code generated by GopherKit.Test; DO NOT EDIT.\n\n")
	allAssertions.WriteString("package assert\n\n")
	allAssertions.WriteString("import \"testing\"\n\n")

	for _, spec := range assertionSpecs {
		assertionSpec, err := g.parseAssertionSpec(spec)
		if err != nil {
			return fmt.Errorf("failed to parse assertion spec %s: %w", spec, err)
		}

		tmpl, err := template.New("assertion").Parse(assertionTemplate)
		if err != nil {
			return fmt.Errorf("failed to parse assertion template: %w", err)
		}

		var buf strings.Builder
		if err := tmpl.Execute(&buf, assertionSpec); err != nil {
			return fmt.Errorf("failed to execute assertion template: %w", err)
		}

		allAssertions.WriteString(buf.String())
		allAssertions.WriteString("\n\n")
	}

	outputPath := filepath.Join(g.OutputDir, "custom_assertions.go")
	return g.writeFile(outputPath, allAssertions.String())
}

// Helper functions

// parseInterface parses a Go interface from a file and extracts its information.
func (g *Generator) parseInterface(interfacePath string) (*InterfaceInfo, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, interfacePath, nil, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("failed to parse file: %w", err)
	}

	var interfaceInfo *InterfaceInfo
	ast.Inspect(file, func(n ast.Node) bool {
		if typeSpec, ok := n.(*ast.TypeSpec); ok {
			if interfaceType, ok := typeSpec.Type.(*ast.InterfaceType); ok {
				interfaceInfo = &InterfaceInfo{
					Name:    typeSpec.Name.Name,
					Package: g.PackageName,
					Methods: g.extractMethods(interfaceType),
				}
				return false
			}
		}
		return true
	})

	if interfaceInfo == nil {
		return nil, fmt.Errorf("no interface found in file")
	}

	return interfaceInfo, nil
}

// extractMethods extracts method information from an interface type.
func (g *Generator) extractMethods(interfaceType *ast.InterfaceType) []MethodInfo {
	var methods []MethodInfo

	for _, method := range interfaceType.Methods.List {
		if funcType, ok := method.Type.(*ast.FuncType); ok {
			for _, name := range method.Names {
				methodInfo := MethodInfo{
					Name:    name.Name,
					Params:  g.extractParams(funcType.Params),
					Returns: g.extractParams(funcType.Results),
				}
				methods = append(methods, methodInfo)
			}
		}
	}

	return methods
}

// extractParams extracts parameter information from a field list.
func (g *Generator) extractParams(fieldList *ast.FieldList) []ParamInfo {
	if fieldList == nil {
		return nil
	}

	var params []ParamInfo
	for i, field := range fieldList.List {
		paramType := g.typeToString(field.Type)
		
		if len(field.Names) == 0 {
			// Unnamed parameter
			params = append(params, ParamInfo{
				Name: fmt.Sprintf("arg%d", i),
				Type: paramType,
			})
		} else {
			// Named parameters
			for _, name := range field.Names {
				params = append(params, ParamInfo{
					Name: name.Name,
					Type: paramType,
				})
			}
		}
	}

	return params
}

// typeToString converts an AST type expression to a string.
func (g *Generator) typeToString(expr ast.Expr) string {
	switch t := expr.(type) {
	case *ast.Ident:
		return t.Name
	case *ast.StarExpr:
		return "*" + g.typeToString(t.X)
	case *ast.ArrayType:
		if t.Len == nil {
			return "[]" + g.typeToString(t.Elt)
		}
		return "[" + g.typeToString(t.Len) + "]" + g.typeToString(t.Elt)
	case *ast.SelectorExpr:
		return g.typeToString(t.X) + "." + t.Sel.Name
	case *ast.InterfaceType:
		return "interface{}"
	default:
		return "interface{}"
	}
}

// generateMockCode generates mock code for an interface.
func (g *Generator) generateMockCode(interfaceInfo *InterfaceInfo) (string, error) {
	tmpl, err := template.New("mock").Parse(mockTemplate)
	if err != nil {
		return "", fmt.Errorf("failed to parse mock template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, interfaceInfo); err != nil {
		return "", fmt.Errorf("failed to execute mock template: %w", err)
	}

	return buf.String(), nil
}

// parseAssertionSpec parses an assertion specification string.
// Format: "name:params:condition:defaultMessage"
func (g *Generator) parseAssertionSpec(spec string) (*AssertionSpec, error) {
	parts := strings.Split(spec, ":")
	if len(parts) != 4 {
		return nil, fmt.Errorf("invalid assertion spec format, expected 'name:params:condition:defaultMessage'")
	}

	return &AssertionSpec{
		Name:           parts[0],
		Params:         parts[1],
		Condition:      parts[2],
		DefaultMessage: parts[3],
	}, nil
}

// writeFile writes content to a file, creating directories as needed.
func (g *Generator) writeFile(path, content string) error {
	dir := filepath.Dir(path)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("failed to create directory %s: %w", dir, err)
	}

	file, err := os.Create(path)
	if err != nil {
		return fmt.Errorf("failed to create file %s: %w", path, err)
	}
	defer file.Close()

	if _, err := file.WriteString(content); err != nil {
		return fmt.Errorf("failed to write to file %s: %w", path, err)
	}

	return nil
}
